---
title: '프로젝트 구조'
metaTitle: 'Project Structure'
metaDescription: 'Notes on project structure and other rough ReScript guidelines'
sourceUrl: 'https://rescript-lang.org/docs/manual/latest/project-structure'
canonical: 'https://rescript-lang.org/docs/manual/latest/project-structure'
---

이들은 현재 커뮤니티에서 지켜지고 있는 불문율들입니다. 우리는 언젠가 이 중 일부를 삭제할 수 있고, 일부는 강제할 수 있습니다. 지금 이것들은 그냥 초보자들의 편의를 위한 가이드입니다.

## 파일 캐싱(File Casing)

파일 이름은 대문자로 시작하세요.

**이유**: 모듈의 이름은 대문자로 시작해야 합니다. 초보자들은 파일이 모듈에 어떻게 매핑되는지, 그리고 왜 `draw.res`는 `Draw`모듈에 매핑하는지 묻고, 대문자로 시작하지 않는 식별자를 통해 모듈을 참조하려는 경우가 있습니다. `Draw.res`를 사용하면 이 매핑이 더 간단해집니다. 또한 `uRI.res`처럼 소문자로 표기하면 어색한 파일 이름의 경우에도 도움이 됩니다.

## .merlin확장자 파일 무시하기

이 파일은 빌드 시스템에 의해 생성됩니다. 그리고 사용자는 그것을 수정할 필요가 없습니다. 굳이 레포지토리에 있는지 체크할 필요 없습니다.

**이유**: `.merlin`은 에디터용 기능입니다. 그 파일은 크로스 플랫폼이 아닌, 절대 경로를 포함하고 있습니다. (예를 들어 Windows 경로들은 다릅니다.)

## 폴더

너무 많은 폴더들이 중첩되지 않도록 하세요. 프로젝트를 수평적으로 만들고, 적은 파일들로 구성되게 하세요. (물론 중첩된 모듈들을 사용할 수는 있습니다.)

**이유**: 파일 시스템은 _tree_구조이지만, 코드의 종속성은 _graph_구조 입니다. 그렇기 때문에, 모든 파일과 폴더의 구성은 불완전합니다. 관련된 파일들을 하나의 폴더에 두는 것은 가치 있는 일지만, 그것을 위한 토론과 결정으로 인한 시간 낭비는 그것에서 오는 장점을 능가합니다. 우리는 이런 이슈에 대해 토론하는 것보다 작업을 마치는 것을 더 추천합니다.

## Third-party 의존성

최소한이 되도록 하세요.

**이유**: 컴파일된 정적인 형식의 언어는 동적 언어에서처럼, 특히 NPM/Yarn에서 여전히 piggy-backing(중단기적으로 학습 부담을 줄이기 위해) 중일 때, 그 의존성을 쉽게 모델링 할 수 없습니다. 의존성을 단순하고, 군더더기 없이 유지하는 것은 충돌 가능성을 줄이는 것에 도움이 됩니다(예를 들어 두 개의 다이아몬드 종속성(diamond dependencies) 또는 인터페이스 충돌(clashing interfaces)같은).

## 문서(Documentation)

문서(Documentation)를 작성해 보세요. 화려하게 보이려 하기보다는 전문적이고 좋게 만들기 위해 더 노력을 기울이세요. 예시를 사용하고, `foo` 나 `bar` 같은 이름들은 사용하지 마세요. 항상 더 구체적인 이름을 쓰세요(예시이기 때문에, 아직 추상화나 일반화가 필요하지는 않습니다. API 문서는 이 작업이 많이 필요할 것입니다.). 블로그에 게시할 때 문서 전체를 반복하지 말고, 새로운 버전이 되면서 _바뀐 부분_과 그 이유를 설명하세요.(예: "그건 컴포넌트였는데, 지금은 함수입니다. 왜냐하면 ...")

**이유**: 초보자들은 단순하고 깔끔한 라이브러리와 화려하게 생긴 라이브러리를 구별해 내기 어렵습니다. 공공의 이익을 위해서, 다른 사람의 라이브러리보다 한 수 위에 있으려고 애쓰지 마세요. 이 부분 꼭 명심하시고, 다른 사람들에게도 알려주세요!

## PPX & Other Meta-tools

최소한이 되도록 하세요. 유명한 경우를 제외하면(예: printer, accessors and serializer/deserializer generation), PPX는 초보자들에게 학습적 동요를 일으킬 수 있습니다. 초보자들이 배워야 하는 syntax, semantics, types, build tool & FFI 외에, 코드의 라이브러리 별 사용자 지정 변환을 학습하는 것은 다음 단계입니다. 침투적인 매크로는 코드 자체를 덜 의미 있게 만들기도 하는데, 본질이 다른 곳에 숨어있기 때문입니다.

## 패러다임(Paradigm)

지나치게 화려한 기능들을 악용하지 마세요. 향후 API를 위한 숨통을 터놓되, 지나치게 설계하지는 마세요.

**이유**: 간단한 코드는 초보자의 이해를 돕고 여러분의 코드에 잠재적인 기여자가 될 수 있도록 도와줍니다. 코드에 기여하는 것은 초보자들이 코드를 학습하는 데 있어 가장 좋은 방법입니다. 여러분이 받는 그런 도움은 조금 더 영리한 언어적 트릭을 사용할 때 얻는 이득보다 클 수도 있습니다. 다만 좀 더 캐주얼한 프로젝트에서는 새로운 언어적 트릭들을 많이 시도해 보세요! 코드를 설계하는 새로운 방법을 발견할지도 모르니까요.

## 게시(Publishing)

자바스크립트 라이브러리용 래퍼인 경우, 자바스크립트 아티팩트를 게시하지 마세요. 제대로 된 라이브러리라면, 자바스크립트 사용자가 사용할 수 있다고 생각하면 lib/js로 아티팩트를 게시합니다. 특히 자바스크립트 라이브러리를 점차적으로 리스크립트로 변환하면서 기존의 자바스크립트 사용자들에게 영향을 주지 않는 않는 경우를 말합니다.

`"rescript"`를 여러분의 package.json 파일의 `keywords`필드에 넣어두세요. 나중에 필요한 라이브러리를 더 쉽게 찾게 해줄 것입니다.

**이유**: 여러분의 라이브러리를 사용하는 자바스크립트 사용자들에게 친절하게 대해주세요. 그들은 여러분 미래의 리스크립터들 입니다!