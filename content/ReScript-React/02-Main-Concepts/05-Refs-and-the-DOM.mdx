---
title: Refs와 DOM
metaTitle: 05-Refs와 DOM(Refs and the DOM)
metaDescription: '리스크립트와 리액트에서 Refs와 DOM 요소 사용하기'
canonical: 'https://rescript-lang.org/docs/react/latest/refs-and-the-dom'
sourceUrl: 'https://rescript-lang.org/docs/react/latest/refs-and-the-dom'
---

Refs는 컴포넌트 함수 `make`로 만들어진 DOM 노드나 리액트 요소에 접근하는 방법을 제공합니다.

일반적인 리액트 데이터 흐름상 오직 [props](./components-and-props)를 통해서만 부모 컴포넌트와 자식 컴포넌트와 상호작을 할 수 있습니다. 자식 요소를 수정하기 위해서는 새로운 props 를 통해 다시 렌더링 시켜야 합니다. 그러나 there are a few cases where you need to imperatively modify a child outside of the typical dataflow. The child to be modified could be an `React.element`, or it could be a `Dom.element`. For both of these cases, React provides an escape hatch.

`React.ref`의 정의는 다음과 같습니다.

```reason
type t<'value> = { mutable current: 'value }
```

> _Note that the `Ref.ref` should not to be confused with the builtin [ref type](/docs/manual/latest/mutation), the language feature that enables mutation._

## 언제 Refs를 사용하나요

refs가 필요한 몇가지 괜찮은 케이스가 있습니다.

- 어떠한 재 렌더링도 _발생시키지 않는_ 상태 관리
- 포커스, 문자열 선택 또는 미디어 재생 관리
- 명령형 애니메이션을 트리거 시킬 때
- 서드 파티 DOM 라이브러리 통합

선언적으로 수행할 수 있는 모든 작업에는 refs 를 사용하지 마세요.

## Refs 생성하기

A React ref is represented as a `React.ref('value)` type, a container managing a mutable value of type `'value`. You can create this kind of ref with the [React.useRef](./hooks-ref) hook:

```reason
@react.component
let make = () => {
  let clicks = React.useRef(0);

  let onClick = (_) => {
    clicks.current = clicks.current + 1;
  };

  <div onClick>
    {Belt.Int.toString(clicks.current)->React.string}
  </div>
}
```

The example above defines a binding `clicks` of type `React.ref(int)`. Note how changing the value `clicks.current` doesn't trigger any re-rendering of the component.

## Refs 접근하기

ref가 요소가 렌더링중 전해질 때, When a ref is passed to an element during render, a reference to the node becomes accessible at the current attribute of the ref.

```reason
let value = myRef.current
```

The value of the ref differs depending on the type of the node:

- When the ref attribute is used on an HTML element, the ref passed via `ReactDOM.Ref.domRef` receives the underlying DOM element as its current property (type of `React.ref<Js.Nullable.t<Dom.element>>`)
- In case of interop, when the ref attribute is used on a custom class component (based on JS classes), the ref object receives the mounted instance of the component as its current (not discussed in this document).
- **You may not use the ref attribute on component functions** because they don’t have instances (we don't expose JS classes in ReScript).

여기 몇가지 예제가 있습니다.

### DOM 요소에 Ref 추가하기

This code uses a `React.ref` to store a reference to an `input` DOM node to put focus on a text field when a button was clicked:

```reason
/* CustomTextInput.res */

@bs.send external focus: Dom.element => unit = "focus"

@react.component
let make = () => {
  let textInput = React.useRef(Js.Nullable.null)

  let focusInput = () =>
    switch textInput.current->Js.Nullable.toOption {
    | Some(dom) => dom->focus
    | None => ()
    }

  let onClick = _ => focusInput()

  <div>
    <input type_="text" ref={ReactDOM.Ref.domRef(textInput)} />
    <input type_="button" value="Focus the text input" onClick />
  </div>
}
```

A few things happened here, so let's break them down:

- We initialize our `textInput` ref as a `Js.Nullable.null`
- We register our `textInput` ref in our `<input>` element with `ReactDOM.Ref.domRef(textInput)`
- In our `focusInput` function, we need to first verify that our DOM element is set, and then use the `focus` binding to set the focus

React will assign the `current` field with the DOM element when the component mounts, and assign it back to null when it unmounts.

### Refs와 컴포넌트 함수

리액트에서 우리는 `ref` 속성을 컴포넌트 함수에 인자로 사용할 수 없습니다.

```reason
module MyComp = {
  @react.component
  let make = (~ref) => <input />
}

@react.component
let make = () => {
  let textInput = React.useRef(Js.Nullable.null)

  /* 이 코드는 컴파일이 되지 않습니다. */
  <MyComp ref={ReactDOM.Ref.domRef(textInput)} />
}
```

```js
/* Compiler Error: */
/* Ref cannot be passed as a normal prop. Please use `forwardRef` */
/* API instead */
```

위 예시는 컴파일 되지 않고 다음과 같은 에러를 뿜을 것입니다. `"Ref cannot be passed as a normal prop. Please use forwardRef API instead."`.

As the error message implies, If you want to allow people to take a ref to your component function, you can use [ref forwarding](./forwarding-refs) (possibly in conjunction with useImperativeHandle) instead.

## Exposing DOM Refs to Parent Components

자주 있는 경우는 아니지만 우리는 부모 컴포넌트로부터 자식의 DOM 노드에 접근하고 싶을 때가 있습니다. 이건 일반적으로 추천되지 않는 방법입니다. 왜냐면 이것은 컴포넌트 캡슐화를 망쳐버리기 때문입니다. 하지만 포커스를 트리거하거나 자식 DOM 노드의 크기 또는 위치를 측정하는 데 유용 할 수 있습니다.

we recommend to use [ref forwarding](./forwarding-refs) for these cases. **Ref forwarding lets components opt into exposing any child component’s ref as their own**. You can find a detailed example of how to expose a child’s DOM node to a parent component in the ref forwarding documentation.

## 콜백 Refs

React also supports another way to set refs called “callback refs” (`React.Ref.callbackDomRef`), which gives more fine-grain control over when refs are set and unset.

Instead of passing a ref value created by `React.useRef()`, you can pass in a callback function. The function receives the target `Dom.element` as its argument, which can be stored and accessed elsewhere.

**참고** Usually we'd use `React.Ref.domRef()` to pass a ref value, but for callback refs, we use `React.Ref.callbackDomRef()` instead.

The example below implements a common pattern: using the ref callback to store a reference to a DOM node in an instance property.

```reason
/* CustomTextInput.re */

@bs.send external focus: Dom.element => unit = "focus"

@react.component
let make = () => {
  let textInput = React.useRef(Js.Nullable.null)
  let setTextInputRef = element => {
    textInput.current = element;
  }

  let focusTextInput = _ => {
    textInput.current
    ->Js.Nullable.toOption
    ->Belt.Option.forEach(input => input->focus)
  }

  <div>
    <input type_="text" ref={ReactDOM.Ref.callbackDomRef(setTextInputRef)} />
    <input
      type_="button" value="Focus the text input" onClick={focusTextInput}
    />
  </div>
}
```

리액트는 컴포넌트가 마운트 될 때 DOM 요소로 ref 콜백을 호출하고 마운트 해제 될 때 null을 호출합니다.

`React.useRef()`로 생성 된 객체 참조와 마찬가지로 컴포넌트 요소간에 콜백 참조를 전달할 수 있습니다.

```reason
/* Parent.res */

@bs.send external focus: Dom.element => unit = "focus"

module CustomTextInput = {
  @react.component
  let make = (~setInputRef) => {
    <div>
      <input type_="text" ref={ReactDOM.Ref.callbackDomRef(setInputRef)} />
    </div>
  }
}

@react.component
let make = () => {
  let textInput = React.useRef(Js.Nullable.null)
  let setInputRef = element => { textInput.current = element}

  <CustomTextInput setInputRef/>
}
```

위 예시에서, `Parent`는 ref 콜백을 `setInputRef` props 으로 `CustomTextInput`에 전달하고 `CustomTextInput`은 특별한  ref 속성과 동일한 함수를 `<input>`에 전달합니다. 결과적으로 Parent의 `textInput` ref는 `CustomTextInput`의 `<input`요소에 해당하는 DOM 노드로 설정됩니다.
