---
title: 엘레멘트와 JSX
metaTitle: 01-엘레멘트와 JSX(Elements & JSX)
metaDescription: '리액트 엘레먼트의 기본 컨셉과 JSX에서의 사용법'
canonical: 'https://rescript-lang.org/docs/react/latest/elements-and-jsx'
sourceUrl: 'https://rescript-lang.org/docs/react/latest/elements-and-jsx'
---

엘레먼트는 리액트 애플리케이션의 가장 작은 빌딩 블럭입니다. 이 페이지에서는 전용 JSX 문법을 사용해 `React.element` 를 어떻게 조작하는지 설명합니다. 

> **참고** 여기서는 여러분의 `bsconfig.json` 설정이 `"reason": { "react-jsx": 3 }`로 설정되어 있다고 가정합니다. 그렇지 않으면 JSX가 React 특정 형식으로 변환되지 않습니다.

## 기본 엘레먼트

우리의 첫 리액트 엘레먼트를 만들어보죠!

```reason
let element = <h1> {React.string("Hello World")} </h1>
```

`element` 바인딩과 `{React.string("Hello World")}` 표현식은 둘 다 리액트 애플리케이션 내에서 리액트 요소를 나타내는 기본 타입인 `React.element` 타입입니다. 엘레먼트는 애플리케이션을 DOM에 렌더링 할 때마다 화면에 표시되는 내용을 설명합니다.

`children`과 같은 다른 리액트 엘레먼트를 처리하는 함수를 만들고 싶다면 `React.element` 어노테이션을 작성해 사용하면 됩니다.

```reason
let wrapChildren = (children: React.element) => {
  <div>
    <h1> {React.string("Overview")} </h1>
    children
  </div>
}

wrapChildren(<div> React.string("Let's use React with ReScript") </div>)
```

`React.element`의 정의를 이해하는 것은 `ReactDOM.render(element, ...)` 등 리액트 API 에서 많이 사용되기 때문에 필수적입니다. JSX는 `문자열`을 `React.element` 로 자동으로 변환해주지 않습니다. (리스크립트는 이 타입 변환을 명시적으로 강제합니다). 예를 들어 `<div> Hello World </div>`의 경우는 타입 검사를 하지 않습니다. (which is actually a good thing because it's also a huge source for subtle bugs!), 여러분은 우선 `"Hello World"`에 `React.string` 함수를 사용해야합니다.

다행히 리스크립트의 리액트 바인딩은 관련 데이터 유형을 모두 `React.element` 변환하는 기능을 제공합니다.

## JSX 와 엘리먼트 사용하기

JSX를 이용하는 복잡한 엘레먼트 합성을 할 수 있습니다.

```reason
let greeting = React.string("Hello ")
let name = React.string("Stranger");


/* element 의 type은 React.element 입니다 */
let element = <div className="myElement"> greeting name </div>
```

JSX는 리액트 애플리케이션의 엘레먼트 트리를 표현하는 주요한 방법입니다.

때때로, 기존 리액트 코드베이스와 상호 운용을 수행할 때 구문 제한으로 JSX 구문을 사용할 수 없는 상황에 놓이게 될 때도 있습니다. 이럴 때의 해결방법은 나중에 [이스케이프 해치](#escape-hatches) 챕터를 확인하세요.

## 엘레먼트 만들기

### 문자열, 정수, 실수, 배열로부터 엘레먼트 만들기

Apart from using JSX to create our React elements or React components, the `React` module offers various functions to create elements from primitive data types:

```reason
React.string("Hello") // new element representing "Hello"

React.int(1) // new element representing "1"

React.float(1.0) // new element representing "1.0"
```

It also offers `React.array` to represent multiple elements as one single element (useful for rendering a list of data, or passing children):

```reason
let element = React.array([
  React.string("element 1"),
  React.string("element 2"),
  React.string("element 3")
])
```

**참고** We don't offer a `React.list` function because a `list` value would impose runtime overhead. ReScript cares about clean, idiomatic JS output. If you want to transform a `list` of elements to a single React element, combine the output of `Belt.List.toArray` with `React.array` instead.

### Creating Null Elements

ReScript doesn't allow `element || null` constraints due to it's strongly typed nature. Whenever you are expressing conditionals where a value might, or might not be rendered, you will need the `React.null` constant to represent _Nothingness_:

```reason
let name = Some("Andrea")

let element = switch name {
  | Some(name) => <div> {React.string("Hello " ++ name)} </div>
  | None => React.null
}

<div> element </div>
```

```js
var name = 'Andrea';

var element = name !== undefined ? React.createElement('div', undefined, 'Hello ' + name) : null;

React.createElement('div', undefined, element);
```

## Escape Hatches

**참고** This chapter features low level APIs that are used by JSX itself, and should only be used whenever you hit certain JSX syntax limitations. More infos on the JSX internals can be found in our [Beyond JSX](./beyond-jsx) section.

### Creating Elements from Component Functions

**참고** Details on components and props will be described in the [next chapter](./components-and-props).

Sometimes it's necessary to pass around component functions to have more control over `React.element` creation. Use the `React.createElement` function to instantiate your elements:

```reason
type props = {"name": string};

let render = (myComp: props => React.element) => {
  <div>
    {React.createElement(myComp, {"name": "Franz"})}
  </div>
}
```

This feature is often used when interacting with existing JS / ReactJS code. In pure ReScript React applications, you would rather pass a function that does the rendering for you (also called a "render prop"):

```reason
let render = (renderMyComp: (~name: string) => React.element) => {
  <div>
    {renderMyComp("Franz")}
  </div>
}
```

#### Pass Variadic Children

There is also a `React.createElementVariadic` function, which takes an array of children as a third parameter:

```reason
type props = {"title": string, "children": React.element};

let render = (article: props => React.element) => {
  let children = [React.string("Introduction"), React.string("Body")];

  let props = {"title": "Article #1", "children": React.null};

  {React.createElementVariadic(article, props, children)}
}
```

```js
function render(article) {
  var children = ['Introduction'];
  var props = {
    title: 'Article #1',
    children: null,
  };
  return Caml_splice_call.spliceApply(React.createElement, [article, props, children]);
}
```

**참고** Here we are passing a prop `"children": React.null` to satisfy the type checker. React will ignore the children prop in favor of the children array.

This function is mostly used by our JSX transformations, so usually you want to use `React.createElement` and pass a children prop instead.

### Creating DOM Elements

To create DOM elements (`<div>`, `<span>`, etc.), use `ReactDOMRe.createDOMElementVariadic`:

```reason
ReactDOMRe.createDOMElementVariadic("div", ~props=ReactDOM.domProps(~className="card", ()), []);
```

The function above requires the `ReactDOM.domProps` constructor function, so ReScript can make sure that we are only passing valid dom props. You can find an exhaustive list of all available props in the [ReactDOM](https://github.com/reasonml/reason-react/blob/master/src/ReactDOM.re#L61) module.

**Warning:** The `ReactDOMRe` module will be removed in the next major `rescript-react` release, so use sparsely!

### Cloning Elements

**참고** This is an escape hatch feature and will only be useful for interoping with existing JS code / libraries.

Sometimes it's required to clone an existing element to set, overwrite or add prop values to a new instance, or if you want to set invalid prop names such as `data-name`. You can use `React.cloneElement` for that:

```reason
let original = <div className="hello"/>

// Will return a new React.element with className set to "world"
React.cloneElement(original, {"className": "world", "data-name": "some name"});
```

```js
var original = React.createElement('div', {
  className: 'hello',
});

React.cloneElement(original, {
  className: 'world',
  'data-name': 'some name',
});
```

The feature mentioned above could also replicate `props spreading`, a practise commonly used in ReactJS codebases, but we strongly discourage the usage due to its unsafe nature and its incorrectness (e.g. adding undefined extra props to a component doesn't make sense, and causes hard to find bugs).

In ReScript, we rather pass down required props explicitly to leaf components or use a renderProp instead. We introduced [JSX punning](/docs/manual/latest/jsx#punning) syntax to make the process of passing down props more convenient.
